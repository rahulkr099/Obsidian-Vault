Alright Rahul, here comes a **clean, interview-quality backend machine coding round mock question** for a **Rate Limiter System**.  
This is one of the **most fundamental backend questions**, especially for roles involving scalable systems.

Iâ€™ll keep things simple in wording but realistic in design so you can train at a high level.

---

# ğŸš° **Backend Machine Coding Round â€” Rate Limiter (Token Bucket / IP-based)**

### â± Time Limit: 45â€“60 minutes

### ğŸ¯ Goal: Build a **rate limiting middleware** that restricts clients to X requests per minute.

---

# ğŸ“ **Problem Statement**

Design and implement a **simple IP-based rate-limiter** to prevent clients from making too many requests in a short time.

You may implement:

- **Token Bucket algorithm**, OR
    
- **Fixed window rate limit**, OR
    
- **Sliding window** (bonus)
    

The system should:

- Track requests per IP
    
- Allow only **X requests per minute**
    
- Reject extra requests with a clear error
    
- Reset limits after a window or token refill interval
    

Your implementation must attach to any API route as a **middleware**.

---

# ğŸ”§ **Requirements**

### **1ï¸âƒ£ Middleware Implementation**

Create a middleware like:

```js
rateLimiter({ limit: 60, windowMs: 60000 })
```

It should:

- Extract client IP
    
- Track number of requests
    
- Allow first X requests
    
- Reject extra requests until window resets
    
- Set proper HTTP status code: **429 Too Many Requests**
    

### **2ï¸âƒ£ Token Bucket Logic (If chosen)**

- Bucket capacity = limit
    
- Tokens refill every fixed interval (e.g., every second)
    
- On request:
    
    - If tokens > 0 â†’ allow + decrement
        
    - If tokens = 0 â†’ reject
        

### **3ï¸âƒ£ Fixed Window (Simpler version)**

- Keep track of:
    
    - windowStartTime
        
    - requestCount
        
- If current time > windowStartTime + windowMs:
    
    - Reset counter and start a new window
        

### **4ï¸âƒ£ Response on Limit Exceeded**

Return:

```json
{
  "error": true,
  "message": "Too many requests, try again later"
}
```

### **5ï¸âƒ£ Middleware Placement**

Should work globally or per-route:

```js
app.use(rateLimiter({ limit: 100, windowMs: 60000 }));
```

or

```js
app.get("/api", rateLimiter({ limit: 10 }), handler);
```

---

# ğŸ§ª **Edge Cases to Handle**

- Missing IP header â†’ fallback to `req.ip`
    
- High concurrency â†’ updates must be atomic (use Map + locking or Redis if provided)
    
- Very large request spikes â†’ still correctly throttled
    
- Window boundary issues:
    
    - Requests arriving exactly at boundary
        
- Multiple routes sharing the same limiter
    
- Different limits per route
    
- Server restart (in-memory bucket resets)
    
- Clients behind proxy (X-Forwarded-For)
    

---

# âš™ï¸ **Persistence Options**

### **1ï¸âƒ£ In-Memory (for coding round)**

Use a `Map<ip, { count, timestamp }>`.

### **2ï¸âƒ£ Redis-backed (Bonus)**

- Use `INCR` and `EXPIRE`
    
- Perfect for horizontal scaling
    
- Avoid race conditions
    

Optional:  
Support sliding window using sorted sets + timestamps.

---

# ğŸ“Š **Expected Behavior**

- First X requests â†’ allowed
    
- Remaining requests â†’ blocked with 429
    
- Counter resets after window expires
    
- Performance stays stable under load
    
- Each IP is tracked independently
    

---

# ğŸ“Œ **Example Output**

### Allowed Request:

```json
{
  "success": true,
  "message": "OK"
}
```

### Throttled:

```json
{
  "error": true,
  "message": "Too many requests, try again later"
}
```

---

# â­ **Interviewer Follow-Up Questions**

1. Difference between **Token Bucket**, **Leaky Bucket**, **Fixed Window**, **Sliding Window**?
    
2. Why is Redis used for distributed rate limiting?
    
3. How do you handle rate limiting behind load balancers (XFF header)?
    
4. How to implement rate limits for:
    
    - Per IP
        
    - Per user
        
    - Per API key
        
5. How would you implement **global rate limits**?
    
6. What happens when multiple servers need to share rate-limit state?
    
7. How to handle rate limits for WebSockets?
    

---

# ğŸŒŸ **Bonus Features (To Impress Interviewers)**

- Add response headers showing limits:
    
    - `X-RateLimit-Limit`
        
    - `X-RateLimit-Remaining`
        
    - `X-RateLimit-Reset`
        
- Add exponential cooldown after repeated violations
    
- Add per-user and per-route custom limits
    
- Add JWT-based rate limiting
    
- Add IP whitelist rules
    
- Add cluster-safe version using Redis + LUA script
    

---

If you're ready, I can generate the next backend machine coding round:

â¡ï¸ **11. File Upload (S3 + MIME validation + limits)**  
â¡ï¸ **12. Real-time Notifications (Webhooks/Sockets)**  
â¡ï¸ **13. Payment System (mini Razorpay)**  
â¡ï¸ **14. Log Processing Pipeline**  
â¡ï¸ **15. Comment/Reply System**

Just tell me the next round!