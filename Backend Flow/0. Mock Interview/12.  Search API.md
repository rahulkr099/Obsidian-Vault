Alright Rahul, here comes a sharp and interview-level **Backend Machine Coding Round** mock question for a **Search API** ‚Äî this is asked a lot in real interviews because it tests **query optimization, indexes, partial + prefix search, and clean API design**.

I‚Äôll keep the wording simple but make the logic deep enough for real-world expectations.

---

# üîé **Backend Machine Coding Round ‚Äî Search API**

### ‚è± Time Limit: 45‚Äì60 minutes

### üéØ Goal: Build a **Search API** that supports:

- Partial match
    
- Prefix match
    
- Searching across multiple fields
    
- Optimized queries
    
- Clean, consistent API response
    

---

# üìù **Problem Statement**

Build a **Search API** for a dataset (e.g., Products, Users, Books).  
We‚Äôll use **Users** as the example domain.

Your API must support:

- Searching by **partial text** match
    
- Searching by **prefix match**
    
- Searching across **multiple fields** using OR logic
    
- Returning paginated + sorted results
    
- Optimized lookups using indexes (design + explanation)
    

---

# üë§ **User Model Structure**

```json
{
  "id": "uuid",
  "name": "Rahul Sharma",
  "email": "rahul@gmail.com",
  "city": "Delhi",
  "createdAt": "...",
  "updatedAt": "..."
}
```

Search must work across:

- `name`
    
- `email`
    
- `city`
    

---

# üîß **Required Endpoint**

```
GET /search?query=rah&fields=name,email&mode=partial&page=1&limit=10
```

---

# üí° **Functional Requirements**

### **1Ô∏è‚É£ Query Param Structure**

#### Mandatory:

- `query` ‚Üí search term
    

#### Optional:

- `fields` ‚Üí comma-separated list of fields  
    Example: `name,email,city`  
    If missing ‚Üí search all indexed fields
    
- `mode`:
    
    - `partial` ‚Üí ‚Äúrah‚Äù should match ‚ÄúRahul Kumar‚Äù
        
    - `prefix` ‚Üí ‚Äúrah‚Äù should match only strings starting with ‚ÄúRah‚Ä¶‚Äù
        
    - default = `partial`
        
- `page`, `limit` ‚Üí pagination
    
- `sort` & `order` (optional):
    
    ```
    /search?sort=name&order=asc
    ```
    

---

### **2Ô∏è‚É£ Search Modes**

#### **Partial Match**

LIKE `%rah%`  
or  
MongoDB: `{ field: /rah/i }`

#### **Prefix Match**

LIKE `rah%`  
or  
MongoDB: `{ field: /^rah/i }`

---

### **3Ô∏è‚É£ Search Logic**

- Combine multiple fields with **OR**  
    Example: query ‚Äúrah‚Äù should match:
    
    - name = "Rahul"
        
    - email = "[r_ah123@gmail.com](mailto:r_ah123@gmail.com)"
        
    - city = "Rajasthan"
        
- Must return:
    
    - paginated results
        
    - total count
        
    - clean objects
        

---

### **4Ô∏è‚É£ Expected Response Structure**

```json
{
  "page": 1,
  "limit": 10,
  "total": 42,
  "data": [
    {
      "id": "u1",
      "name": "Rahul Sharma",
      "email": "rahul@gmail.com",
      "city": "Delhi"
    }
  ]
}
```

---

# üß™ **Edge Cases to Handle**

- Empty `query` ‚Üí return 400
    
- Invalid fields ‚Üí 400
    
- No results ‚Üí return empty list
    
- large limit values ‚Üí cap at max (e.g., 100)
    
- query with special characters ‚Üí escape properly
    
- Text search should be **case-insensitive**
    
- Page out of bounds ‚Üí return empty
    
- Multiple spaces in search text (normalize it)
    
- MongoDB regex slowdown for non-indexed fields ‚Üí warn interviewer
    
- SQL LIKE `%text%` can be slow without index ‚Üí mention covering index
    

---

# ‚öôÔ∏è **Performance + Indexing Requirements (Very Important)**

Interviewers LOVE testing this.

### **1Ô∏è‚É£ Index design (MongoDB)**

You should create:

- Index on `name`
    
- Index on `email`
    
- Index on `city`
    
- Or compound index based on usage:
    
    ```
    { name: 1, email: 1, city: 1 }
    ```
    

### **2Ô∏è‚É£ Index design (SQL)**

- B-tree indexes on each searchable column
    
    ```
    CREATE INDEX idx_users_name ON users(name);
    CREATE INDEX idx_users_email ON users(email);
    CREATE INDEX idx_users_city ON users(city);
    ```
    

### **3Ô∏è‚É£ Avoid full table scans**

- Using LIKE `%query%` prevents index use in SQL.
    
- Recommend:
    
    - Trigram index
        
    - Full-text search index
        
    - Prefix search (`query%`) to enable index usage
        

### **4Ô∏è‚É£ Mention how you'd scale**

- Use ElasticSearch for advanced search
    
- Or use Redis search module
    
- Or precomputed lowercase columns for faster comparisons
    

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. Why does SQL index not work with `%text%` search?
    
2. How do you implement case-insensitive search efficiently?
    
3. What‚Äôs the difference between **full-text search** and **LIKE search**?
    
4. When would you use **ElasticSearch** instead of DB search?
    
5. How would you prevent regex-based DoS attacks?
    
6. How would you support **typo tolerance** (‚Äúrahul‚Äù ~ ‚Äúrahl‚Äù)?
    
7. How would you build **autocomplete** with prefix search?
    
8. How do you add ranking / scoring to search results?
    

---

# üåü **Bonus Features (Impressive Add-ons)**

- Highlight matched text in results
    
- Add fuzzy search using:
    
    - Levenshtein distance
        
    - ElasticSearch ‚Äúfuzzy‚Äù query
        
- Add field-level boosts (email > name > city)
    
- Support AND + OR combinations
    
- Support pagination using cursors
    
- Add sorted search results by relevance
    
- Add caching for top search queries
    

---

If you want the next backend round, I can prepare:

‚û°Ô∏è **13. File Upload + S3 + MIME validation**  
‚û°Ô∏è **14. Payment System (mini Razorpay)**  
‚û°Ô∏è **15. Notification System (Email/SMS/Webhook)**  
‚û°Ô∏è **16. Comment/Reply Backend**  
‚û°Ô∏è **17. Blogging Backend with Auth + CRUD + Search**

Just tell me the next one!