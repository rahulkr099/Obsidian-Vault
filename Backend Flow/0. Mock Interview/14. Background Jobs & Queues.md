Alright Rahul, here comes a strong, realistic, and interview-quality **Backend Machine Coding Round** mock question for **Background Jobs + Queues (BullMQ-style)**.  
This round is commonly asked at companies dealing with emails, SMS, heavy processing, and async workflows.

I‚Äôll keep wording simple but include deep logic to help you train like a pro.

---

# üîÅ **Backend Machine Coding Round ‚Äî Background Jobs & Queues**

### ‚è± Time Limit: 60‚Äì90 minutes

### üéØ Goal: Build a small background job system using a queue (like **BullMQ**, **BeeQueue**, or custom implementation).

The system should support:

- Email sending job
    
- SMS sending job
    
- Cleanup jobs
    
- Retry logic
    
- Delayed jobs
    
- Worker processing
    

---

# üìù **Problem Statement**

Design a mini backend system that:

- Accepts job requests (Email, SMS, Cleanup)
    
- Pushes them into a job queue
    
- A worker picks up jobs asynchronously
    
- Job executes (simulate actual logic)
    
- Supports retries, failure handling, and logging
    
- Provides an endpoint to check job status
    

You may use:

- **Node.js + Express**
    
- **BullMQ / Bull / BeeQueue / Custom queue**
    
- **Redis** (if using real queue)
    
- Or in-memory queue for simulation
    

---

# üß± **Required APIs**

```
POST   /jobs/email
POST   /jobs/sms
POST   /jobs/cleanup
GET    /jobs/:id/status
```

---

# üí° **Functional Requirements**

## **1Ô∏è‚É£ Add Email Job ‚Äî POST /jobs/email**

Input:

```json
{
  "to": "rahul@example.com",
  "subject": "Hello",
  "body": "This is a test email"
}
```

Rules:

- Validate email
    
- Validate subject & body
    
- Create a job in queue:
    
    ```
    type = "email"
    payload = { to, subject, body }
    ```
    
- Return the jobId
    

---

## **2Ô∏è‚É£ Add SMS Job ‚Äî POST /jobs/sms**

Input:

```json
{
  "phone": "+919999999999",
  "message": "Your OTP is 1234"
}
```

Rules:

- Validate phone number
    
- Validate message
    
- Add job to queue with:
    
    ```
    type = "sms"
    payload = { phone, message }
    ```
    

---

## **3Ô∏è‚É£ Add Cleanup Job ‚Äî POST /jobs/cleanup**

This simulates:

- deleting temp files
    
- removing old logs
    
- expiring old session data
    

Payload example:

```json
{
  "task": "delete_temp"
}
```

Job type: `cleanup`

May support scheduling:

```
{ delay: 60000 } // run after 60 sec
```

---

## **4Ô∏è‚É£ Job Status ‚Äî GET /jobs/:id/status**

Return job info:

```json
{
  "id": "job123",
  "type": "email",
  "status": "completed",
  "attempts": 1,
  "result": "Email sent successfully"
}
```

Allowed status values:

- queued
    
- processing
    
- completed
    
- failed
    
- delayed
    

---

# ‚öôÔ∏è **Worker Requirements (Important)**

Worker should:

- Continuously pull jobs from queue
    
- Handle jobs based on type:
    
    - email ‚Üí simulate sending
        
    - sms ‚Üí simulate sending
        
    - cleanup ‚Üí simulate file cleanup
        
- Support:
    
    - retries
        
    - backoff (exponential or linear)
        
    - error catching
        
- Mark job as:
    
    - completed with result
        
    - failed with error
        
- Persist job history (in memory or with Redis)
    

---

# üß™ **Edge Cases to Handle**

- Invalid input ‚Üí 400
    
- Queue overload ‚Üí graceful handling
    
- Worker crash ‚Üí pending jobs should retry on restart
    
- Job retry:
    
    - transient error
        
    - network failure
        
    - random failure simulation
        
- Delayed jobs must not run immediately
    
- Duplicate jobs (optional: dedupe logic)
    
- Race conditions:
    
    - ensure job not processed twice
        
- Maximum retries exceeded ‚Üí mark failed
    
- Worker should not block main request loop
    
- job status query:
    
    - non-existing job ‚Üí 404
        

---

# üîí **Performance & Safety Requirements**

- Queue must be FIFO
    
- Worker must be independent from API server
    
- Backoff mechanism:
    
    - e.g., retry after 5 sec
        
- Maximum retry limit (e.g., 3 attempts)
    
- Logs for each stage:
    
    - job added
        
    - job picked
        
    - job processed
        
    - job completed
        
    - job failed
        

---

# üì¶ **Example Queue Data Structure (In-Memory)**

```json
{
  "id": "job_1001",
  "type": "email",
  "status": "processing",
  "payload": { ... },
  "attempts": 2,
  "maxAttempts": 3,
  "result": null,
  "error": null,
  "createdAt": "...",
  "updatedAt": "..."
}
```

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. How do you ensure **at-least-once** delivery?
    
2. Difference between **Bull**, **BullMQ**, **RabbitMQ**, **Kafka**?
    
3. Why queue vs running email directly?
    
4. How do you handle **worker crashes** and **restarts**?
    
5. How do you design **delayed jobs**?
    
6. How would you implement **dead-letter queues** (DLQ)?
    
7. How would you scale workers horizontally?
    
8. How to make the system **idempotent**? (avoid double sending email)
    
9. What if the job depends on another job? (chained jobs)
    

---

# üåü **Bonus Features (To Impress)**

- Add priority queues
    
- Add concurrency limit (2 workers process jobs simultaneously)
    
- Add monitoring dashboard for jobs
    
- Add events (job succeeded / failed / stalled)
    
- Add cron jobs (run daily cleanup at midnight)
    
- Add separate queues:
    
    - `emailQueue`
        
    - `smsQueue`
        
    - `cleanupQueue`
        
- Add encryption for sensitive fields (OTP/SMS)
    
- Add Sentry logging for failures
    

---

If you want the next backend challenge, I can prepare:

‚û°Ô∏è **15. Payment System (Mini Razorpay / Stripe)**  
‚û°Ô∏è **16. Real-time Notification System**  
‚û°Ô∏è **17. Comment System (Nested replies)**  
‚û°Ô∏è **18. Chat Backend (WebSockets + History)**

Just tell me the next round!