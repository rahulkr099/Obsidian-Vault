Alright Rahul, here comes a simple but solid **Backend Machine Coding Round** mock question for a **Bookmark / Favorites API**.  
This is a common task in real interviews because it tests **CRUD, idempotency, duplicate prevention, clean DB modeling, and filtering**.

I'll keep everything easy to read and forward-thinking.

---

# üß© **Backend Machine Coding Round ‚Äî Bookmark / Favorites API**

### ‚è± Time Limit: 35‚Äì45 minutes

### üéØ Goal

Build a backend API where users can **add, remove, and fetch bookmarks**, while preventing duplicates.

Use any stack: Node.js, Express, MongoDB/SQL, or in-memory for quick logic.

---

# üì¶ **Bookmark Model Structure**

A bookmark usually relates **user ‚Üí resource**:

```json
{
  "id": "uuid",
  "userId": "user_123",
  "itemId": "prod_551",  
  "type": "product",      
  "createdAt": "timestamp"
}
```

(You may choose to support types like: product, article, video, etc.)

---

# üîß **Required Endpoints**

```
POST   /bookmarks
DELETE /bookmarks
GET    /bookmarks?type=product
```

---

# üí° **Functional Requirements**

### **1Ô∏è‚É£ Add Bookmark ‚Äî POST /bookmarks**

Input:

```json
{
  "userId": "user_123",
  "itemId": "prod_551",
  "type": "product"
}
```

Rules:

- All fields required
    
- Prevent duplicates:
    
    - Same userId + itemId + type ‚Üí should NOT create a second entry
        
- If already exists:
    
    - Either return same entry
        
    - Or return `409 Conflict` (your choice)
        

Return newly created bookmark.

---

### **2Ô∏è‚É£ Remove Bookmark ‚Äî DELETE /bookmarks**

Input:

```json
{
  "userId": "user_123",
  "itemId": "prod_551",
  "type": "product"
}
```

Rules:

- Must match exactly
    
- If bookmark doesn't exist ‚Üí return 404
    
- If removed ‚Üí return success message
    

---

### **3Ô∏è‚É£ Get All Bookmarks ‚Äî GET /bookmarks**

Supports filters:

```
/bookmarks?userId=user_123
/bookmarks?userId=user_123&type=product
```

Return list ordered by `createdAt DESC`.

Response:

```json
{
  "userId": "user_123",
  "count": 4,
  "data": [
    { "itemId": "prod_551", "type": "product" }
  ]
}
```

---

# üß™ **Edge Cases to Handle**

- Duplicate bookmark creation ‚Üí block and return meaningful output
    
- Delete bookmark not found ‚Üí 404
    
- Missing userId/itemId/type ‚Üí 400
    
- Invalid type (if types predefined) ‚Üí 400
    
- Query without userId ‚Üí 400
    
- Multiple bookmarks fast ‚Üí ensure DB unique constraint
    
- Large dataset ‚Üí pagination:
    
    ```
    /bookmarks?userId=u1&page=1&limit=20
    ```
    
- Idempotent DELETE:
    
    - Second delete call should return safe error or success (your decision)
        

---

# üß± **Data Modeling Requirements**

To prevent duplicates:

### MongoDB:

Create unique compound index:

```js
{ userId: 1, itemId: 1, type: 1 }
```

### SQL:

```
UNIQUE (user_id, item_id, type)
```

This guarantees:

- One user can bookmark one item only once
    
- High concurrency safe
    

---

# üìä **Expected Response Examples**

### Add:

```json
{
  "success": true,
  "bookmark": {
    "id": "b1",
    "userId": "user_123",
    "itemId": "prod_551",
    "type": "product"
  }
}
```

### Remove:

```json
{
  "success": true,
  "message": "Bookmark removed"
}
```

### List:

```json
{
  "userId": "user_123",
  "count": 3,
  "data": [
    { "itemId": "prod_551", "type": "product" },
    { "itemId": "blog_22", "type": "article" }
  ]
}
```

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. How do you enforce **uniqueness** in DB to prevent duplicates?
    
2. How would you add **pagination** and sorting?
    
3. How would you let users **favorite multiple types** (products, movies, blogs) efficiently?
    
4. How would you scale this to millions of bookmarks?
    
5. How do you design a **toggle bookmark** endpoint?
    
6. How would you add a **bookmark count** for each item?
    

---

# üåü **Bonus Improvements to Impress**

- Add `/bookmarks/toggle` ‚Üí adds if missing, removes if present
    
- Add timestamp range filtering
    
- Add Redis caching for quick bookmark lookups
    
- Store bookmark categories/tags
    
- Add sync bookmark system across devices
    
- Support ‚Äúfolder-like‚Äù organization (e.g., Bookmark lists)
    

---

If you want the next backend round, I can prepare:

‚û°Ô∏è **17. Notification / Webhook System**  
‚û°Ô∏è **18. Blog Backend**  
‚û°Ô∏è **19. Comment System (nested replies)**  
‚û°Ô∏è **20. Payment Flow (mini Razorpay)**

Just tell me the next one!