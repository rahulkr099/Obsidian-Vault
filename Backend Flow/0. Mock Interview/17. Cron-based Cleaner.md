Alright Rahul, here comes a clean, interview-ready **Backend Machine Coding Round** mock question for a **Cron-based Cleaner System**.  
This is a common backend test because it checks **scheduled tasks, cleanup logic, cron patterns, TTL handling, and safe deletion**.

Iâ€™ll keep it simple and forward-looking so it fits real-world expectations.

---

# â± **Backend Machine Coding Round â€” Cron-based Cleaner**

### â± Time Limit: 30â€“45 minutes

### ğŸ¯ Goal: Build a mini backend system where a **cron job runs every X minutes** and deletes expired or stale data (e.g., expired links).

---

# ğŸ“ **Problem Statement**

You must build a backend service that:

- Stores records with expiry timestamps
    
- Runs a cron job periodically (every X minutes)
    
- Detects expired entries
    
- Deletes or archives them safely
    
- Logs all actions
    
- Does not block the main API thread
    

Common example: deleting **expired short URLs** or **expired sessions**.

---

# ğŸ“¦ **Example Data Structure**

Let's assume you are cleaning up **expired short links**:

```json
{
  "id": "uuid",
  "url": "https://example.com/demo",
  "shortCode": "abc123",
  "expiresAt": "2025-01-03T10:00:00Z",
  "createdAt": "..."
}
```

---

# ğŸ”§ **Required Components**

1. **API to create new items** (with TTL)
    
2. **Cron scheduler** running every X minutes
    
3. **Cleanup logic**
    
4. **Logs** of what was deleted
    
5. **Safe, idempotent delete operation**
    

---

# ğŸ”§ **Required Endpoint**

### **Create Expirable Item**

```
POST /items
```

Input:

```json
{
  "url": "https://google.com",
  "ttl": 3600
}
```

Behavior:

- `expiresAt = now + ttl`
    
- Store in DB / memory
    
- Return created item
    

---

# ğŸ” **Cron Job Requirements**

Use any scheduler:

- `node-cron`
    
- BullMQ repeatable jobs
    
- setInterval (not recommended but OK for mock)
    
- OS-level crontab (if explaining architecture)
    

Cron should run every X minutes (e.g., 5 minutes):

```
*/5 * * * *
```

### Cron Behavior:

1. Find all items where:
    
    ```
    expiresAt < currentTime
    ```
    
2. Delete them from database
    
3. Log:
    
    - number of items deleted
        
    - IDs of deleted items
        
4. Cron must be **idempotent**:
    
    - Running twice should not double-delete
        
5. Should never block API routes
    

---

# ğŸ§ª **Edge Cases to Handle**

- Items with no TTL â†’ should not be deleted
    
- TTL <= 0 â†’ expire immediately
    
- Large number of expired items â†’ batch delete
    
- Partial deletion failure â†’ retry safely
    
- Cron should not overlap:
    
    - Prevent multiple instances running concurrently
        
- Server restart:
    
    - Cron must restart automatically
        
- Clock drift (system time shift)
    
- Race condition:
    
    - Item being accessed while cron deletes it
        
- Past timestamps:
    
    - If expiresAt already passed â†’ delete on next run
        

---

# âš™ï¸ **Performance Expectations**

- Use index on `expiresAt` for fast lookup
    
- Delete in batches (SQL: LIMIT 1000)
    
- Avoid full table scans
    
- Donâ€™t log thousands of IDs (use summary)
    
- Cron should not slow down main server
    

---

# ğŸ“Š **Expected Output Example**

### After cron run:

Log:

```
[Cleaner] Deleted 4 expired items at 12:30PM
```

Or store logs in DB:

```json
{
  "runAt": "2025-01-03T12:30:00Z",
  "deletedCount": 4
}
```

---

# â­ **Interviewer Follow-Up Questions**

1. How do you prevent **multiple cron jobs** from running on multi-instance deployments?
    
2. How do you avoid **double deletion**?
    
3. What if cron fails mid-way? How do you retry safely?
    
4. How would you implement **soft-delete** instead of hard delete?
    
5. How would you implement **TTL index in MongoDB** so cron is not needed?
    
6. Why is setInterval not reliable for production cron?
    
7. How would you scale this to millions of expirable records?
    
8. How do you add metrics for cron performance?
    

---

# ğŸŒŸ **Bonus Features (Impressive Add-ons)**

- Add a `/cron/run-now` endpoint (admin only)
    
- Add soft-delete + restoration
    
- Add S3 cleanup for expired assets
    
- Use Redis-based distributed lock (so only one server runs cron)
    
- Add email notifications for deleted items
    
- Add dashboard showing:
    
    - next run
        
    - last run
        
    - deleted count history
        
- Add batched deletion with asynchronous worker
    
- Add retry + backoff if DB deletion fails
    

---

If you want next backend round, I can prepare:

â¡ï¸ **18. Comment System (nested threaded replies)**  
â¡ï¸ **19. Blog CRUD + Search + Tags**  
â¡ï¸ **20. Real-time Chat Backend (WebSockets)**  
â¡ï¸ **21. Mini Social Media Backend (Likes + Posts + Feed)**

Just tell me the next one!