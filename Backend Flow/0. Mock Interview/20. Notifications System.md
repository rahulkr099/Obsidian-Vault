Alright Rahul, here comes a crisp and interview-ready **Backend Machine Coding Round** mock question for a **Mini Notification System**.  
This is a very common backend task because it tests **CRUD, state updates, unread counters, clean modeling, and efficient queries**.

I‚Äôll keep everything simple to read but solid in depth ‚Äî perfect for real interviews.

---

# üì¨ **Backend Machine Coding Round ‚Äî Notification System (Mini)**

### ‚è± Time Limit: 45‚Äì60 minutes

### üéØ Goal

Build a backend API for managing notifications with:

- Create notification
    
- Mark one as read
    
- Mark all as read
    
- Get unread count
    
- Clean, efficient data modeling
    

---

# üóÇ Notification Model

Each notification belongs to a user.

```json
{
  "id": "uuid",
  "userId": "user_123",
  "title": "New Message",
  "message": "You have a new message from Sam",
  "isRead": false,
  "createdAt": "timestamp"
}
```

Optional:

- `type`: "info" | "warning" | "success" | "chat"
    
- `redirectUrl`: link to open when user clicks
    
- `priority`: low/medium/high
    

---

# üîß Required Endpoints

```
POST   /notifications
GET    /notifications?userId=...
PUT    /notifications/:id/read
PUT    /notifications/read-all?userId=...
GET    /notifications/unread-count?userId=...
```

---

# üí° Functional Requirements

## **1Ô∏è‚É£ Create Notification ‚Äî POST /notifications**

Input:

```json
{
  "userId": "user_123",
  "title": "New Like",
  "message": "Someone liked your post"
}
```

Behavior:

- Validate fields
    
- Save notification with `isRead = false`
    
- Return created notification
    

---

## **2Ô∏è‚É£ Get Notifications ‚Äî GET /notifications?userId=123**

Support:

- Pagination ‚Üí `page=1&limit=10`
    
- Filtering by `type`
    
- Sorting (latest first)
    

Response:

```json
{
  "page": 1,
  "limit": 10,
  "total": 42,
  "data": [ ... ]
}
```

---

## **3Ô∏è‚É£ Mark Notification as Read ‚Äî PUT /notifications/:id/read**

Behavior:

- Only update if `isRead = false`
    
- If already read ‚Üí return safe message
    
- Update `isRead = true`
    

---

## **4Ô∏è‚É£ Mark All as Read ‚Äî PUT /notifications/read-all?userId=...**

Behavior:

- Update all notifications for the user
    
- Should be atomic (single DB update)
    
- Avoid looping in the app layer
    

Example response:

```json
{
  "updated": 32,
  "message": "All notifications marked as read"
}
```

---

## **5Ô∏è‚É£ Get Unread Count ‚Äî GET /notifications/unread-count?userId=...**

Return:

```json
{
  "userId": "user_123",
  "unreadCount": 5
}
```

Should use:

- Fast count query
    
- Index on `(userId, isRead)` for performance
    

---

# üß™ Edge Cases to Handle

- Missing userId ‚Üí 400
    
- Notification not found on mark-read ‚Üí 404
    
- Mark-read on another user's notification ‚Üí 403
    
- Mark-all-read for empty list ‚Üí success with 0 updates
    
- Duplicate notifications allowed (depends on system)
    
- Flooding with notifications ‚Üí pagination needed
    
- Large unread counts ‚Üí store cached count (bonus)
    

---

# üß± Backend Logic Requirements

- Indexes:
    
    - `userId`
        
    - `userId + isRead`
        
    - `createdAt`
        
- Use database UPDATE queries:
    
    ```
    UPDATE notifications SET isRead = true WHERE userId = ?
    ```
    
- Should avoid race conditions:
    
    - Two clients marking at same time
        
    - Mark-read & mark-all-read conflict
        

---

# üìä Example API Responses

### Create:

```json
{
  "success": true,
  "id": "n_100",
  "isRead": false
}
```

### Mark one:

```json
{
  "success": true,
  "message": "Notification marked as read"
}
```

### Mark all:

```json
{
  "success": true,
  "updated": 19
}
```

---

# ‚≠ê Interviewer Follow-Up Questions

1. How will you optimize unread count?
    
2. How will you handle **real-time notifications** (WebSockets)?
    
3. How would you send push notifications (FCM/APNs)?
    
4. How would you implement folder/bucket-based notifications (categories)?
    
5. How would you run a daily cleanup job for old notifications?
    
6. How do you store unread counts efficiently?
    
7. Should we push or pull notifications?
    
8. How would you secure notification actions per user?
    

---

# üåü Bonus Features (Good to Impress)

- Add WebSocket `/subscribe` to push notifications live
    
- Add `priority` sorting (high first)
    
- Add click tracking logs
    
- Add `DELETE /notifications/:id`
    
- Add categories (promotions, social, alert, security)
    
- Add Redis cache for unread count
    
- Add email / SMS fallback notifications
    
- Add marking multiple selected notifications read
    

---

If you want the next backend challenge, I can prepare:

‚û°Ô∏è **21. Comments System (Nested Replies)**  
‚û°Ô∏è **22. Social Feed Backend**  
‚û°Ô∏è **23. Real-Time Chat Backend**  
‚û°Ô∏è **24. Product Review System**

Just tell me the next round!