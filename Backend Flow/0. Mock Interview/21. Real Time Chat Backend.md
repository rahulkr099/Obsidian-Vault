Alright Rahul, here comes a **high-quality, interview-ready machine coding round** mock question for a **Real-Time Chat Backend using WebSockets**.  
This is one of the most common advanced backend rounds because it tests **WebSockets, real-time messaging, room management, message delivery guarantees, typing indicators, and persistence**.

I‚Äôll keep it simple to read but deep enough for real interviews.

---

# üí¨ **Backend Machine Coding Round ‚Äî Real-Time Chat Backend (WebSocket)**

### ‚è± Time Limit: 60‚Äì90 minutes

### üéØ Goal

Build a **mini real-time chat server** using WebSockets that supports:

- Connecting/disconnecting users
    
- One-to-one messaging
    
- Chat rooms
    
- Saving chat history
    
- Online/offline status
    
- Typing indicators (optional)
    

You may use:  
Node.js + WebSocket / Socket.IO / ws library.

---

# üìù **Problem Statement**

Design a **real-time chat backend** where:

- Users connect via WebSocket
    
- They can send messages to another user
    
- Server broadcasts messages instantly
    
- Messages are saved in a database
    
- Users can fetch chat history
    
- Server shows user online/offline state
    
- Should handle reconnections safely
    

Real-time events + persistent storage are required.

---

# üì¶ **Data Models**

### **User**

```json
{
  "id": "u123",
  "name": "Rahul"
}
```

### **Message**

```json
{
  "id": "m123",
  "senderId": "u123",
  "receiverId": "u555",
  "content": "Hello!",
  "timestamp": "2025-01-03T10:00:00Z",
  "isRead": false
}
```

### **Optional (Room Chat)**

```json
{
  "roomId": "room_1",
  "participants": ["u1", "u2"]
}
```

---

# üîß **Required Features**

## **1Ô∏è‚É£ WebSocket Connection**

- When client connects ‚Üí authenticate (via token or ID)
    
- Mark user as **online**
    
- Store mapping: `userId -> socketId`
    

Server emits:

```json
{ "event": "user_online", "userId": "u123" }
```

---

## **2Ô∏è‚É£ Send Message (Real-Time)**

Client emits:

```json
{
  "event": "send_message",
  "data": {
    "to": "u555",
    "content": "Hello!"
  }
}
```

Server tasks:

1. Validate message
    
2. Save message to DB
    
3. If receiver online ‚Üí push instantly
    
4. If offline ‚Üí store unread
    
5. Emit acknowledgment to sender
    

Server emits to receiver:

```json
{
  "event": "new_message",
  "data": { "from":"u123","content":"Hello!" }
}
```

---

## **3Ô∏è‚É£ Chat History Fetching (HTTP route)**

```
GET /messages?user1=u123&user2=u555
```

Return:

```json
[
  { "from":"u123","content":"Hello!","timestamp":"..." },
  ...
]
```

---

## **4Ô∏è‚É£ Mark Messages as Read**

Client emits:

```json
{
  "event": "mark_read",
  "data": {
    "from": "u123"
  }
}
```

Server updates DB for unread messages from `u123`.

---

## **5Ô∏è‚É£ User Disconnect**

- Mark user as offline
    
- Clean socket map
    
- Notify others
    

```json
{ "event": "user_offline", "userId": "u555" }
```

---

# ‚≠ê Optional Enhancements (if time allows)

### **Typing indicator**

```
event: typing_start
event: typing_stop
```

### **Chat Rooms**

```
join_room, send_room_message, leave_room
```

### **Message delivery confirmation**

```
sent ‚Üí delivered ‚Üí read
```

### **Reconnect Handling**

- Restore user session
    
- Resend missed events
    
- Update online status
    

---

# üß™ **Edge Cases to Handle**

- Duplicate connections (same user logged in twice)
    
- Dropped connections ‚Üí auto-reconnect
    
- Large messages ‚Üí validate size
    
- Message loss when server restarts (must save DB first)
    
- Offline message queue
    
- Receiver blocked ‚Üí do not deliver
    
- Database slowdown ‚Üí message buffering
    
- Spam prevention (rate limiting)
    
- Room flood (100 users sending messages together)
    
- Ensuring message ordering for each conversation
    

---

# üß† **Backend Logic Requirements**

- Maintain `onlineUsers` map
    
- Use event-driven structure:
    
    - onConnection
        
    - onMessage
        
    - onDisconnect
        
- Use a database like MongoDB, SQL, or in-memory for storage
    
- Use UUID for messageIDs
    
- Event acknowledgements for reliability
    
- Must scale WebSocket connections safely
    

---

# üåê **Scaling / Architecture Considerations (Interviewer Will Ask)**

1. How to scale WebSockets behind load balancers?
    
2. Why use Redis Pub/Sub or Kafka for distributed messaging?
    
3. How to handle message ordering?
    
4. How to ensure no duplicate message delivery?
    
5. Why sticky sessions or session affinity?
    
6. How to shard chat rooms?
    
7. How to implement push notifications for mobile users?
    
8. How to implement end-to-end encryption? (optional but impressive)
    

---

# ‚≠ê Interviewer Follow-Up Questions

- How would you handle 100k active WebSocket connections?
    
- How would you store chat history efficiently?
    
- Why choose WebSockets over SSE/long-polling?
    
- How to support group chats efficiently?
    
- How to detect and handle toxic messages (content moderation)?
    

---

If you want the next one, I can prepare:

‚û°Ô∏è **21. Social Media Feed Engine (posts, likes, feed)**  
‚û°Ô∏è **22. Comment System (nested replies)**  
‚û°Ô∏è **23. Mini Analytics Engine**  
‚û°Ô∏è **24. File-sharing + Realtime presence**

Just tell me the next round!