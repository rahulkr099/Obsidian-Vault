Alright Rahul, here comes a **realistic, interview-grade backend machine coding round** for a **Mini Payment System (Razorpay-style)**.  
This is one of the _most_ common advanced backend rounds because it tests **payment flows, order creation, signatures, webhook handling, consistency, and security**.

I‚Äôll keep the words simple but the system deep enough to match real company expectations.

---

# üí≥ **Backend Machine Coding Round ‚Äî Mini Razorpay Payment System**

### ‚è± Time Limit: 75‚Äì90 minutes

### üéØ Goal

Build a mini-payment service that supports:

- Creating a payment order
    
- Processing a payment (mock)
    
- Verifying payment signature
    
- Handling webhooks
    
- Updating payment & order status
    
- Ensuring safe + idempotent operations
    

Use Node.js/Express and any DB.

---

# üìù **Problem Statement**

Design a backend payment system similar to Razorpay with these features:

- Client creates a **payment order**
    
- Server returns orderId + amount
    
- Client ‚Äúpays‚Äù using a dummy payment gateway simulation
    
- Payment gateway sends a **webhook** with payment details
    
- Backend verifies signature
    
- Backend updates payment status (SUCCESS / FAILED)
    
- Backend marks the related _order_ as PAID
    
- Must support **idempotent webhook handling**
    

---

# üì¶ **Data Models**

### **Order**

```json
{
  "id": "order_123",
  "amount": 1500,
  "currency": "INR",
  "status": "CREATED", // CREATED, PAID, FAILED
  "createdAt": "...",
  "updatedAt": "..."
}
```

### **Payment**

```json
{
  "id": "pay_555",
  "orderId": "order_123",
  "status": "INITIATED", // INITIATED, SUCCESS, FAILED
  "signature": null,
  "gatewayPaymentId": null,
  "createdAt": "...",
  "updatedAt": "..."
}
```

---

# üîß **Required Endpoints**

```
POST /orders
POST /payments/initiate
POST /webhook/payment
GET  /orders/:id
```

---

# üí° **Functional Requirements**

## **1Ô∏è‚É£ Create Order ‚Äî POST /orders**

Input:

```json
{
  "amount": 1500,
  "currency": "INR"
}
```

Behavior:

- Validate amount > 0
    
- Create order with:
    
    - unique orderId
        
    - status = CREATED
        
- Return:
    

```json
{
  "orderId": "order_123",
  "amount": 1500,
  "currency": "INR"
}
```

---

## **2Ô∏è‚É£ Initiate Payment ‚Äî POST /payments/initiate**

Input:

```json
{
  "orderId": "order_123"
}
```

Behavior:

- Find order
    
- Create payment entry:
    
    - status = INITIATED
        
- Simulate payment gateway:
    
    - generate gatewayPaymentId
        
    - generate signature using secret
        
- Return mocked gateway info
    

Example Response:

```json
{
  "paymentId": "pay_555",
  "orderId": "order_123",
  "gatewayPaymentId": "gw_991",
  "signature": "<signed-hash>"
}
```

---

## **3Ô∏è‚É£ Payment Webhook ‚Äî POST /webhook/payment**

The payment gateway ‚Äúcalls‚Äù this after payment simulation.

Example webhook payload:

```json
{
  "orderId": "order_123",
  "paymentId": "pay_555",
  "gatewayPaymentId": "gw_991",
  "signature": "<signed-hash>",
  "status": "SUCCESS"
}
```

Backend must:

### ‚úî Verify Signature

- Using secret key
    
- Recompute hash over:
    
    ```
    orderId + "|" + gatewayPaymentId
    ```
    

If signature invalid:

- reject webhook ‚Üí 400
    
- do not update DB
    

### ‚úî Idempotent Handling

- If webhook for same payment arrives twice ‚Üí process only once
    
- Avoid double updates
    

### ‚úî Update Payment Status

- SUCCESS ‚Üí update
    
- FAILED ‚Üí update
    

### ‚úî Update Order Status

If payment successful:

- Order.status = PAID  
    Else:
    
- Order.status = FAILED
    

Return:

```json
{ "success": true }
```

---

## **4Ô∏è‚É£ Get Order Details ‚Äî GET /orders/:id**

Return:

- order info
    
- payment info (if exists)
    

---

# üß™ **Edge Cases Interviewers Expect**

- Invalid orderId / paymentId
    
- Duplicate webhook events
    
- Signature mismatch (security violation)
    
- Order already marked PAID ‚Üí ignore further updates
    
- Status update race conditions
    
- Amount mismatch (if payment gateway amount differs)
    
- Missing fields in payload
    
- Timestamp skew in webhooks
    
- Partial DB update ‚Üí atomic transaction needed
    
- Payment received but order not updated ‚Üí must avoid inconsistent state
    
- Client tries to pay again after success ‚Üí block
    

---

# üîí **Security Requirements**

- Use HMAC SHA256 signature check
    
- Secret key stored in environment variable
    
- Reject signature mismatch
    
- Ensure idempotency (most important)
    
- Limit webhook route via IP allowlist (bonus)
    
- Validate amount/currency from order vs gateway
    

---

# ‚öôÔ∏è **Backend Logic Requirements**

- Clean architecture:
    
    - controllers
        
    - services
        
    - repository
        
    - utils for signature
        
- Use UUIDs for order & payment IDs
    
- Use transactions for updating order + payment atomically
    
- Use idempotency check:
    
    - store webhook eventId
        
    - or store **payment status** and ignore reprocessing
        

---

# ‚ùó Must-Have Behaviors

- Payment must always map to **one** order
    
- Order status must reflect true final state
    
- No double updates
    
- No inconsistent payment/order combos
    
- Payment lifecycle:
    
    ```
    INITIATED ‚Üí SUCCESS or FAILED
    ```
    

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. How do you ensure **idempotency** of webhook calls?
    
2. Why use **HMAC SHA256** and not plain hashing?
    
3. How do real gateways like Razorpay prevent fraud?
    
4. How do you ensure **atomicity** of order + payment update?
    
5. How would you support:
    
    - UPI
        
    - Cards
        
    - Wallets
        
    - Net banking
        
6. What happens if the payment gateway webhook arrives **before** the frontend callback?
    
7. How do you design retries if webhook fails due to server error?
    
8. How do you implement **refunds**?
    
9. How do you extend this for subscription payments?
    

---

# üåü **Bonus Features (To Impress)**

- Add **refund API**
    
- Add **receipt generation (PDF)**
    
- Add **webhook retry mechanism**
    
- Add **signing-key rotation**
    
- Add **payment logs table**
    
- Add **email notification** on successful payment
    
- Add **rate limit** on `/webhook/payment`
    
- Add **dashboard** for payment analytics
    
- Add **checksum validation** for extra safety
    

---

If you want the next machine coding round, I can create:

‚û°Ô∏è **21. Social Media Feed System**  
‚û°Ô∏è **22. Comment System (Nested replies)**  
‚û°Ô∏è **23. Admin Audit Log System**  
‚û°Ô∏è **24. Authentication + Refresh Tokens**  
‚û°Ô∏è **25. Searchable Blog Platform**

Just tell me the next one, Rahul!