Alright Rahul ‚Äî here comes a **top-tier, interview-grade backend machine coding round** for a **Notification Delivery System** (Email + SMS + Webhooks).

This problem is **very popular** in real interviews because it tests:

- async queues
    
- safe delivery
    
- retries
    
- webhooks
    
- email/SMS integrations
    
- consistency
    
- extensible architecture
    

I‚Äôll keep it simple to read but deep enough for actual company-level backend rounds.

---

# üì¨ **Backend Machine Coding Round ‚Äî Notification System (Email, SMS, Webhooks)**

### ‚è± Time Limit: 75‚Äì90 minutes

### üéØ Goal

Build a backend notification system that can:

- Accept notification requests
    
- Send email, SMS, and webhook notifications
    
- Use queues for async processing
    
- Retry failed deliveries
    
- Log all notifications
    
- Provide delivery status
    

Use Node.js + Express + Redis/BullMQ + DB (SQL/Mongo).

---

# üìù **Problem Statement**

Design a **centralized notification service** where:

- Client sends notification job ‚Üí API
    
- Server puts job in queue (email, sms, webhook)
    
- Worker processes jobs asynchronously
    
- Delivery result stored in DB
    
- Client can query notification status
    
- System supports retries + backoff
    
- Webhook notifications must POST data to external URL
    

You can mock actual email/SMS sending.

---

# üì¶ **Data Models**

### **Notification Job**

```json
{
  "id": "notif_123",
  "type": "email",   // email | sms | webhook
  "recipient": "user@example.com",
  "payload": { ... },
  "status": "queued",   // queued | processing | success | failed
  "attempts": 0,
  "maxAttempts": 3,
  "createdAt": "...",
  "updatedAt": "..."
}
```

### **Payloads**

#### Email:

```json
{
  "subject": "Welcome!",
  "body": "Thanks for signing up"
}
```

#### SMS:

```json
{
  "message": "Your OTP is 1234"
}
```

#### Webhook:

```json
{
  "url": "https://clientapp.com/callback",
  "data": { "userId": "123", "event": "payment_success" }
}
```

---

# üîß **Required Endpoints**

```
POST   /notify/email
POST   /notify/sms
POST   /notify/webhook
GET    /notifications/:id
```

Each POST must:

1. Validate input
    
2. Create notification job
    
3. Push job into queue
    
4. Return jobId
    

---

# üí° **Functional Requirements**

## **1Ô∏è‚É£ Create Email Notification ‚Äî POST /notify/email**

Input:

```json
{
  "to": "rahul@example.com",
  "subject": "Hi Rahul",
  "body": "Welcome!"
}
```

Steps:

- Validate email
    
- Save job with type=email
    
- Enqueue
    
- Return notificationId
    

---

## **2Ô∏è‚É£ Create SMS Notification ‚Äî POST /notify/sms**

Input:

```json
{
  "phone": "+919876543210",
  "message": "Your order is shipped!"
}
```

Steps:

- Validate phone
    
- Save job
    
- Enqueue
    

---

## **3Ô∏è‚É£ Create Webhook Notification ‚Äî POST /notify/webhook**

Input:

```json
{
  "url": "https://client.com/event",
  "data": { "status": "success", "user": "u123" }
}
```

Steps:

- Validate URL
    
- Store job
    
- Enqueue
    

Worker should perform:

- HTTP POST request to given URL
    
- Retry on failures
    
- Timeout & backoff
    

---

## **4Ô∏è‚É£ Get Notification Status ‚Äî GET /notifications/:id**

Response:

```json
{
  "id": "notif_123",
  "type": "email",
  "status": "success",
  "attempts": 1
}
```

---

# ‚öôÔ∏è **Worker Requirements (BullMQ or similar)**

For each job:

1. Mark job as `processing`
    
2. Try sending:
    
    - Email: mock via console or nodemailer
        
    - SMS: mock send
        
    - Webhook: axios/fetch HTTP POST
        
3. If success:
    
    - Mark job `success`
        
4. If failure:
    
    - Retry until maxAttempts
        
    - Apply exponential backoff (e.g., 2s ‚Üí 4s ‚Üí 8s)
        
5. If all retries fail:
    
    - Mark job `failed`
        
    - Save error message
        

---

# üîÅ **Retry & Backoff Logic**

Example:

```
attempt 1 ‚Üí wait 2s  
attempt 2 ‚Üí wait 4s  
attempt 3 ‚Üí wait 8s  
```

Store:

```
attempts: 3
status: failed
```

---

# üß™ **Edge Cases Interviewers Will Test**

### Input Validation

- Invalid email
    
- Invalid phone
    
- Invalid webhook URL
    
- Missing required fields
    

### Queue Failures

- Redis down ‚Üí graceful fallback
    
- Worker crash ‚Üí pending jobs must resume
    
- Timeout on webhook HTTP call
    
- Rate-limited webhook URLs
    

### Deduplication (optional)

Prevent sending duplicate notifications.

### Idempotency

- Same webhook triggered twice ‚Üí should not repeat beyond limit
    
- Duplicate job creation ID ‚Üí avoid collisions
    

### Security

- Don‚Äôt allow internal network webhook calls (SSRF protection)
    
- Signed webhook payloads (optional)
    
- Validate request payloads
    

### Performance

- Thousands of pending jobs
    
- Hundreds of retries
    
- Slow external webhook endpoints
    

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. How do you prevent **duplicate notifications**?
    
2. How do you handle **webhook retries** safely?
    
3. How to handle **DLQ (Dead Letter Queue)**?
    
4. What is the difference between:
    
    - job queued
        
    - job scheduled
        
5. Why choose BullMQ over RabbitMQ/Kafka?
    
6. How do you secure webhook callbacks?
    
7. How do you batch SMS via gateways?
    
8. How do you track email delivery (opened/clicked)?
    
9. How to avoid failures when Redis restarts?
    
10. How to scale workers horizontally?
    

---

# üåü **Bonus Features (Excellent Add-ons)**

- Dashboard: show pending, failed, success jobs
    
- Separate queues: `emailQueue`, `smsQueue`, `webhookQueue`
    
- Webhook signature signing (HMAC secret)
    
- Throttling per user (e.g., max 10 SMS/hour)
    
- Email templating system
    
- SMS provider fallback: if Twilio fails ‚Üí use MSG91
    
- Encryption of sensitive fields
    

---

If you want the **next backend machine coding round**, I can generate:

‚û°Ô∏è **22. Comment System (Nested Replies)**  
‚û°Ô∏è **23. Social Feed System (Posts + Likes + Feed)**  
‚û°Ô∏è **24. Analytics Event Collector**  
‚û°Ô∏è **25. Admin Audit Log System**

Just tell me the next one, Rahul!