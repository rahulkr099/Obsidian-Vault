Alright Rahul ‚Äî here‚Äôs a **powerful, interview-quality backend machine coding round** for building a **Social Media Feed Engine** (Posts + Likes + Feed).

This one is VERY popular at companies because it tests:

- relational data modeling
    
- feed generation
    
- pagination
    
- likes
    
- caching
    
- fan-out vs fan-in architecture
    
- performance thinking
    

I‚Äôll keep the language simple, and give you a top-level but interview-ready version.

---

# üì± **Backend Machine Coding Round ‚Äî Social Media Feed Engine**

### ‚è± Time Limit: 75‚Äì90 minutes

### üéØ Goal

Build a backend for a mini social media app that supports:

- Creating posts
    
- Liking/unliking posts
    
- Fetching user feed (paginated)
    
- Counting likes
    
- Feed ordering (latest first)
    

Use Node.js + Express + MongoDB/SQL.

---

# üìù **Problem Statement**

Design a backend where:

- Users can create posts
    
- Users can like/unlike posts
    
- Users can follow each other
    
- A user‚Äôs feed should show posts created by people they follow
    
- Feed must be paginated by time
    
- Feed must show like count & whether current user liked it
    

This is similar to Instagram/Twitter feed basics.

---

# üì¶ **Data Models**

### **User**

```json
{
  "id": "u1",
  "name": "Rahul"
}
```

### **Post**

```json
{
  "id": "p1",
  "userId": "u1",
  "content": "Hello world!",
  "createdAt": "timestamp"
}
```

### **Like**

```json
{
  "userId": "u1",
  "postId": "p1",
  "createdAt": "timestamp"
}
```

### **Follow**

```json
{
  "followerId": "u1",
  "followingId": "u2",
  "createdAt": "timestamp"
}
```

---

# üîß **Required Endpoints**

```
POST   /posts
GET    /posts/:postId
POST   /posts/:postId/like
DELETE /posts/:postId/like
GET    /feed?userId=u1&page=1&limit=10
```

---

# üí° **Functional Requirements**

## **1Ô∏è‚É£ Create Post ‚Äî POST /posts**

Input:

```json
{
  "userId": "u1",
  "content": "Good morning!"
}
```

Rules:

- Content required
    
- Create post with timestamp
    
- Return post ID
    

---

## **2Ô∏è‚É£ Get Single Post ‚Äî GET /posts/:postId**

Return:

```json
{
  "id": "p1",
  "content": "Good morning!",
  "likeCount": 10,
  "likedByUser": true
}
```

---

## **3Ô∏è‚É£ Like a Post ‚Äî POST /posts/:postId/like**

Input:

```json
{ "userId": "u1" }
```

Rules:

- Prevent duplicate likes (unique constraint)
    
- Increase like count
    
- Save timestamp
    
- Return success
    

---

## **4Ô∏è‚É£ Unlike a Post ‚Äî DELETE /posts/:postId/like**

Input:

```json
{ "userId": "u1" }
```

Rules:

- If user hasn‚Äôt liked ‚Üí return safe message
    
- Delete like entry
    
- Decrease like count
    

---

## **5Ô∏è‚É£ Fetch Feed ‚Äî GET /feed**

Example:

```
GET /feed?userId=u1&page=1&limit=10
```

Feed must show:

- Posts by users that `u1` follows
    
- Ordered by newest first
    
- Paginated
    
- Each post enriched with:
    
    - like count
        
    - whether the user liked it
        

Example response:

```json
{
  "page": 1,
  "limit": 10,
  "data": [
    {
      "postId": "p10",
      "content": "New update!",
      "userId": "u3",
      "createdAt": "...",
      "likeCount": 27,
      "likedByUser": false
    }
  ]
}
```

---

# üß† **Feed Generation Approaches (Interviewer Will Ask)**

### **1. Fan-out on read (simple)**

When fetching feed:

- Get list of users the user follows
    
- Fetch posts from those users
    
- Sort by createdAt
    
- Paginate
    

### Pros:

- Simple
    
- No duplication
    

### Cons:

- Slow when user follows many (1000+)
    

---

### **2. Fan-out on write (advanced)**

On post creation:

- Push copy of post to followers‚Äô feed lists (Redis list)
    

Feed retrieval ‚Üí O(1)

### Pros:

- Fast feed
    

### Cons:

- Data duplication
    
- Heavy write operations
    

---

# üß™ **Edge Cases to Handle**

### Posts

- Empty content ‚Üí 400
    
- Very large content ‚Üí limit
    

### Likes

- Duplicate likes ‚Üí prevent
    
- Liking own post ‚Üí allowed/blocked (your choice)
    
- Like count must never go negative
    

### Feed

- User with 0 following ‚Üí empty feed
    
- Pagination ‚Üí skip/limit
    
- Race condition when liking/unliking rapidly
    
- Ensure sorting is correct
    

### Following

- If follow list extremely large
    
- Missing or invalid userId
    

### Performance

- N+1 queries while enriching posts with like status
    
- Use `IN` queries to check likes
    
- Use caching (optional)
    

---

# üß± **Backend Logic Requirements**

- SQL Example Query (Feed):
    

```
SELECT * FROM posts
WHERE userId IN (SELECT followingId FROM follows WHERE followerId = ?)
ORDER BY createdAt DESC
LIMIT ? OFFSET ?
```

- Enrich like counts using either:
    
    - subqueries
        
    - aggregated likes table
        
    - caching layer
        
- Enrich ‚ÄúlikedByUser‚Äù with:
    

```
SELECT * FROM likes WHERE userId = ? AND postId IN (...)
```

- Use indexes:
    
    - `posts.userId`
        
    - `likes.postId`
        
    - `follows.followerId`
        
    - `createdAt`
        

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. How will you scale the feed when a user follows 5000 accounts?
    
2. How to avoid N+1 queries?
    
3. When should you use **fan-out on write** vs **fan-out on read**?
    
4. How would you add:
    
    - comments
        
    - share
        
    - tagging
        
    - trending feed?
        
5. How do you handle spam likes or bots?
    
6. How do you track engagement analytics?
    
7. What if user blocks another user?
    
8. How would you support infinite scroll?
    
9. How would you store media (images/videos) in posts?
    

---

# üåü **Bonus Features (To Impress)**

- Redis caching of feed pages
    
- Like count caching
    
- Pre-computed ‚Äúrecommended feed‚Äù
    
- Engagement ranking algorithms
    
- WebSockets for real-time new post notifications
    
- Support for hashtags & trending topics
    
- Soft delete for posts
    
- Batch fetching for performance
    
- Analytics logs for impressions
    

---

If you want the next one, I can prepare:

‚û°Ô∏è **24. Analytics Event Collector (client ‚Üí server ‚Üí DB)**  
‚û°Ô∏è **25. Audit Log + Admin Panel**  
‚û°Ô∏è **26. Role-Based Access Control System**  
‚û°Ô∏è **27. Product Search + Ranking + Filters (Elastic/OpenSearch style)**

Just tell me the next round, Rahul!