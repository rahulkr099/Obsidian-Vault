Alright Rahul, here comes a **high-quality backend machine-coding mock interview question** for a **URL Shortener API** ‚Äî this is one of the most popular backend rounds because it tests hashing, database design, redirects, analytics, TTL, and performance thinking.

I‚Äôll make the question clean, realistic, and full of smart edge cases so you can prepare like a pro.

---

# ‚úÖ **Backend Machine Coding Round ‚Äî URL Shortener API**

### **‚è± Time Limit:** 60‚Äì90 minutes

### **üéØ Goal:** Build a production-grade URL shortener service with:

- Short URL generation
    
- Redirects
    
- Click analytics
    
- Unique code constraints
    
- Optional TTL expiration
    

---

# **üìù Problem Statement**

Build a **URL Shortener API** similar to Bitly or TinyURL.

System should:

- Accept a long URL and generate a short code
    
- Redirect short URL ‚Üí original URL
    
- Track analytics like:
    
    - total clicks
        
    - last clicked time
        
    - visit history (timestamps + IP/user-agent optional)
        
- Support TTL (auto-expire URLs after a given time)
    

You can use **Node.js/Express + Mongo/SQL** OR in-memory DB for logic demonstration.

---

# **üîó Required Endpoints**

```
POST    /shorten
GET     /:code        (redirect)
GET     /analytics/:code
```

---

# **üìå 1. Shorten URL ‚Äî POST /shorten**

### **Input**

```json
{
  "url": "https://example.com/some/long/path",
  "customCode": "rahul123",   // optional
  "ttl": 3600                 // optional, in seconds
}
```

### **Rules**

- `url` required
    
- Validate URL format
    
- If `customCode` provided:
    
    - must be unique
        
    - must be alphanumeric
        
- If no custom code:
    
    - Generate random code (6‚Äì9 chars)
        
    - Must be unique
        
- Save:
    
    - original URL
        
    - short code
        
    - createdAt
        
    - optional expiresAt = createdAt + ttl
        

### **Response**

```json
{
  "shortUrl": "https://yourdomain.com/rahul123"
}
```

---

# **üìå 2. Redirect ‚Äî GET /:code**

### **Logic**

- Look up code in DB
    
- If not found ‚Üí 404
    
- If expired (TTL reached) ‚Üí 410 Gone
    
- If found:
    
    - Record analytics:
        
        - +1 click count
            
        - update lastClicked timestamp
            
        - append to visit history
            
    - Redirect to original URL
        

### **Response**

HTTP 302 Redirect

---

# **üìå 3. Analytics ‚Äî GET /analytics/:code**

### **Output example**

```json
{
  "code": "xYz89a",
  "url": "https://example.com/long",
  "createdAt": "...",
  "expiresAt": "...",
  "clicks": 14,
  "lastClicked": "2025-01-10T10:00:00Z",
  "history": [
    { "timestamp": "...", "ip": "1.2.3.4", "userAgent": "Firefox" },
    ...
  ]
}
```

---

# **üì¶ Data Modeling (Expected)**

### **URLs Table / Collection**

```
id
originalUrl
shortCode (unique)
createdAt
expiresAt (nullable)
clicks
lastClicked
visitHistory[]     // each entry: timestamp, ip, userAgent
```

Indexes:

- unique index on shortCode
    
- TTL index on expiresAt (MongoDB)
    
- createdAt index (optional)
    

---

# **üß™ Edge Cases to Handle**

- customCode already exists ‚Üí 409 Conflict
    
- invalid URL ‚Üí 400
    
- TTL ‚â§ 0 ‚Üí treat as no expiry
    
- code not found during redirect ‚Üí 404
    
- expired link ‚Üí return 410 Gone
    
- extremely long URLs ‚Üí allow but validate length
    
- random code collision ‚Üí regenerate
    
- analytics history too large ‚Üí truncate or paginate (optional)
    
- redirect loops (URL shortening a short URL) ‚Üí prevent or allow deliberately
    
- high traffic on same URL ‚Üí atomic increment for clicks
    

---

# **üîß Functional Tests Interviewer Expects**

- POST /shorten success
    
- POST with custom code
    
- POST with duplicate custom code ‚Üí error
    
- GET /:code ‚Üí must redirect
    
- GET /:code (expired) ‚Üí 410
    
- GET analytics ‚Üí full metadata
    
- Click counter updates correctly
    
- History logs every visit
    
- TTL expiration works properly
    

---

# ‚≠ê Interviewer Follow-Up Questions

1. How would you generate **collision-free short codes**?
    
2. How would you handle **millions of requests per day**?
    
3. How do you ensure atomic increments on analytics?
    
4. How would you build **global rate limiting**?
    
5. How would you prevent shortening of **malicious URLs**?
    
6. How would you add **user accounts + dashboard**?
    
7. How would you store analytics efficiently (avoid huge arrays)?
    
8. How would you implement **custom domains**?
    

---

# üåü Bonus Features (Great to Impress)

- Add QR code generation for each short URL
    
- Add bulk URL shortening (CSV upload)
    
- Add expiry-based auto-cleaning (cron jobs)
    
- Add preview page: `/preview/:code`
    
- Add link password protection
    
- Add A/B testing through multiple target URLs
    
- Add caching layer (Redis) for faster redirect lookups
    
- Add IP-based analytics & geographic charts
    

---

If you want the next backend system, I can create:

‚û°Ô∏è **6. File Upload System (S3, validation, limits)**  
‚û°Ô∏è **7. Rate Limiting + Caching (Redis)**  
‚û°Ô∏è **8. Order + Payment Workflow**  
‚û°Ô∏è **9. Notification System (Emails, SMS)**  
‚û°Ô∏è **10. Real-time Chat Backend (WebSockets)**

Just tell me the next round!