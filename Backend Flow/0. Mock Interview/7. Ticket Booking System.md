Alright Rahul, here comes a **high-quality backend machine coding round mock question** for a **Ticket Booking System (Mini)**.  
This is one of the toughest backend topics because it tests **concurrency, locking, consistency, seat allocation, and transactional safety** ‚Äî exactly what real interviews look for.

I‚Äôll keep the wording simple but the system deep enough to match industry expectations.

---

# üé´ **Backend Machine Coding Round ‚Äî Ticket Booking System (Mini)**

### **‚è± Time Limit:** 75‚Äì90 minutes

### **üéØ Goal:** Build a safe ticket booking backend with:

- Event creation
    
- Seat availability
    
- Safe seat booking
    
- Prevention of double booking
    
- Concurrency-safe logic
    

---

# üìù **Problem Statement**

Design and implement a **Mini Ticket Booking System** where:

- Admin can create an event with N seats
    
- Users can book a seat
    
- System must prevent **double booking**
    
- Users should be able to check seat availability
    
- All bookings must be **atomic and concurrency-safe**
    

You may use **Node.js + Express**, **SQL with transactions**, OR **in-memory with locking**.

Architecture expected:

- **Routes**
    
- **Controller**
    
- **Service (business logic)**
    
- **Data layer / DB**
    
- (Optional) **Locking Mechanism**
    

---

# üéü **Event Model Structure**

```json
{
  "id": "uuid",
  "name": "React Conference 2025",
  "totalSeats": 100,
  "availableSeats": 100,
  "createdAt": "...",
  "updatedAt": "..."
}
```

---

# ü™ë **Seat Booking Model Structure**

```json
{
  "id": "uuid",
  "eventId": "uuid",
  "seatNumber": 42,
  "userId": "user_123",
  "createdAt": "..."
}
```

Or you may simply store a boolean ‚Äúbooked‚Äù array.

---

# üîß **Required Endpoints**

```
POST    /events
GET     /events/:id
GET     /events/:id/seats
POST    /events/:id/book
```

---

# üí° **Functional Requirements**

### **1Ô∏è‚É£ Create Event ‚Äî POST /events**

Input:

```json
{
  "name": "Tech Summit",
  "totalSeats": 50
}
```

Rules:

- totalSeats > 0
    
- Initialize:
    
    - availableSeats = totalSeats
        
    - seats indexed 1..N
        
- Return eventId
    

---

### **2Ô∏è‚É£ Show Event Details ‚Äî GET /events/:id**

Return full event info including availableSeats.

---

### **3Ô∏è‚É£ Show Available Seats ‚Äî GET /events/:id/seats**

Return current seat map:

```json
[
  { "seatNumber": 1, "booked": false },
  { "seatNumber": 2, "booked": true },
  ...
]
```

---

### **4Ô∏è‚É£ Book a Seat ‚Äî POST /events/:id/book**

Input:

```json
{
  "userId": "u123",
  "seatNumber": 42
}
```

Business rules:

- seatNumber must be valid
    
- seat must not already be booked
    
- event must exist
    
- booking must be **atomic**
    
- update:
    
    - seat ‚Üí booked by user
        
    - decrement availableSeats
        
- return booking confirm details
    

---

# üß™ **Critical Edge Cases (Interviewer Will Focus)**

These determine whether you pass or fail this round.

### üî• **1. Two users try to book the same seat at same time**

- Only one must succeed
    
- The other gets 409 Conflict or 400 with ‚ÄúSeat already booked‚Äù
    
- Must NOT create duplicate seat bookings
    

### üî• **2. DB Consistency**

- If seat booking fails halfway ‚Üí rollback
    
- availableSeats must reflect correct count
    

### üî• **3. Invalid operations**

- Booking on non-existent event ‚Üí 404
    
- Booking seatNumber > totalSeats ‚Üí 400
    
- Already booked ‚Üí 409
    
- availableSeats already 0 ‚Üí 400 (sold out)
    

### üî• **4. Concurrency**

- Must use:
    
    - SQL Transactions (`SELECT FOR UPDATE`)
        
    - Or Distributed Lock (Redis)
        
    - Or In-memory locks (mutex) for demonstration
        

### üî• **5. Idempotency**

- If same user retries booking with same seatNumber ‚Üí second call should fail gracefully or return same booking (optional design)
    

---

# üß¨ **Consistency Requirements (Expected in Good Answers)**

- No race conditions
    
- No inconsistent seat state
    
- No negative availableSeats
    
- No duplicate rows for same seat
    
- No ‚Äúghost bookings‚Äù
    
- System should handle high QPS for booking endpoint
    

---

# üßæ **Sample Responses**

### Booking success:

```json
{
  "success": true,
  "eventId": "e123",
  "seatNumber": 42,
  "userId": "u123",
  "message": "Seat booked successfully"
}
```

### Booking failure:

```json
{
  "error": true,
  "message": "Seat already booked"
}
```

---

# ‚≠ê **Interviewer Follow-Up Questions**

These are MUST-know:

1. How do you prevent double booking under **heavy concurrency**?
    
2. Which locking strategy will you use:
    
    - DB row lock
        
    - Redis distributed lock
        
    - Mutex in memory
        
    - Optimistic locking
        
3. How does `SELECT FOR UPDATE` work?
    
4. What happens if transaction fails halfway?
    
5. How do you scale this system horizontally?
    
6. How do you handle **seat maps for events with 100k seats**?
    
7. How would you support **random seat allocation**?
    
8. How do you add **payment flow** to confirm booking?
    

---

# üåü **Bonus Features (Impressive Add-ons)**

- Auto-assign best available seat (like BookMyShow)
    
- Implement locking with Redis or Redlock
    
- Add seat categories (VIP, Premium, Normal)
    
- Add payment + order confirmation flow
    
- Add expiry:
    
    - Temporary seat hold for 5 minutes
        
- Add booking history per user
    
- Add admin dashboard for analytics
    
- Add WebSockets for real-time seat updates
    

---

If you want next backend system, I can create:

‚û°Ô∏è **8. Rate Limiting + Caching (Redis)**  
‚û°Ô∏è **9. File Upload System (S3 + Validation)**  
‚û°Ô∏è **10. Payment/Order Workflow**  
‚û°Ô∏è **11. Notification System (Emails/SMS/Webhooks)**

Just tell me ‚Äî what‚Äôs your next round?