Alright Rahul, here comes a sharp, interview-ready **backend machine coding round mock question** for an **Inventory Management System**.  
This is a common backend test because it checks **data integrity, stock constraints, concurrency, reorder rules, and clean business logic.**

Let‚Äôs make it simple to read but deep enough to impress any interviewer.

---

# üè≠ **Backend Machine Coding Round ‚Äî Inventory System**

### ‚è± Time Limit: 60‚Äì75 minutes

### üéØ Goal: Build a backend inventory service that handles:

- Adding products
    
- Reducing stock safely
    
- Preventing negative stock
    
- Reorder-level tracking
    
- Clean APIs + robust business logic
    

---

# üìù **Problem Statement**

Build a **mini inventory management backend** with APIs that allow:

- Creating a product
    
- Increasing stock
    
- Reducing stock
    
- Preventing stock from going below zero
    
- Marking products as ‚ÄúLOW STOCK‚Äù when they hit a reorder limit
    
- Querying product details
    

You may use Node.js, Express, SQL/Mongo, or even in-memory DB.

Architecture expected:

- **Routes**
    
- **Controller**
    
- **Service (business logic)**
    
- **Repository** (optional)
    

---

# üì¶ **Product Model Structure**

```json
{
  "id": "uuid",
  "name": "Protein Powder",
  "sku": "PRT-001",
  "stock": 50,
  "reorderLevel": 10,
  "createdAt": "...",
  "updatedAt": "..."
}
```

Constraints:

- `sku` must be **unique**
    
- `stock` and `reorderLevel` must be non-negative integers
    

---

# üîß **Required Endpoints**

```
POST    /products
PUT     /products/:id/add
PUT     /products/:id/reduce
GET     /products/:id
GET     /products/:id/status
```

---

# üí° **Functional Requirements**

### **1Ô∏è‚É£ Create Product ‚Äî POST /products**

Input:

```json
{
  "name": "Laptop",
  "sku": "LTP-123",
  "stock": 20,
  "reorderLevel": 5
}
```

Rules:

- Name required
    
- SKU required + must be unique
    
- Stock ‚â• 0
    
- ReorderLevel ‚â• 0
    
- Return full product object
    

---

### **2Ô∏è‚É£ Increase Stock ‚Äî PUT /products/:id/add**

Input:

```json
{
  "quantity": 30
}
```

Rules:

- quantity > 0
    
- Add to current stock
    
- Update timestamps
    

---

### **3Ô∏è‚É£ Reduce Stock ‚Äî PUT /products/:id/reduce**

Input:

```json
{
  "quantity": 12
}
```

Rules:

- quantity > 0
    
- **Do not allow negative stock**
    
- If `stock < quantity`, return 400
    
- If safe, subtract from stock
    

**This operation must be atomic**, avoiding:

- Double deduction
    
- Race conditions
    
- Inconsistent stock values
    

---

### **4Ô∏è‚É£ Get Product Info ‚Äî GET /products/:id**

Return full details:

- name
    
- sku
    
- stock
    
- reorderLevel
    
- timestamps
    

---

### **5Ô∏è‚É£ Product Status ‚Äî GET /products/:id/status**

Output example:

```json
{
  "sku": "LTP-123",
  "stock": 6,
  "reorderLevel": 5,
  "status": "LOW_STOCK"
}
```

Rules:

- If `stock <= reorderLevel` ‚Üí `LOW_STOCK`
    
- Else ‚Üí `IN_STOCK`
    

---

# üß™ **Edge Cases the Interviewer Will Test**

- Add with negative quantity ‚Üí reject
    
- Reduce with negative/zero quantity ‚Üí reject
    
- Reduce beyond available stock ‚Üí reject
    
- SKU already exists ‚Üí conflict
    
- Product not found ‚Üí 404
    
- Race condition:
    
    - Two users reduce stock at the same time ‚Üí stock must NEVER go negative
        
- Large stock values should not overflow
    
- reorderLevel > stock ‚Üí status = LOW_STOCK
    
- SKU must be case-insensitive unique
    
- Updating stock must also update `updatedAt`
    

---

# üîí **Consistency & Safety Requirements**

This is where interviewers judge candidates:

### **1Ô∏è‚É£ Use database transactions or locking**

Recommended approaches:

- SQL: `SELECT ... FOR UPDATE`
    
- Redis distributed lock
    
- In-memory mutex for demonstration
    

### **2Ô∏è‚É£ Prevent negative stock even under heavy concurrency**

One thread/process should ‚Äúwin‚Äù, others should fail correctly.

### **3Ô∏è‚É£ Strong validation**

Every endpoint must reject invalid or unsafe updates.

---

# üìä Example Responses

### Successful reduction

```json
{
  "success": true,
  "productId": "p123",
  "newStock": 18
}
```

### Failure (insufficient stock)

```json
{
  "error": true,
  "message": "Not enough stock available"
}
```

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. How do you prevent **race conditions** in reduce stock?
    
2. Would you use **optimistic** or **pessimistic** locking? Why?
    
3. How do you ensure SKU uniqueness under concurrency?
    
4. How would you implement **low stock alerts** (email, webhook)?
    
5. How would you scale this with **millions of products**?
    
6. How would you implement **batch stock sync** from warehouses?
    
7. How do you store stock safely? (Why not float?)
    
8. How do you handle soft deletes for products?
    

---

# üåü **Bonus Features (For Extra Points)**

- Redis cache for product lookup
    
- Add event-based architecture for stock updates (Kafka or RabbitMQ)
    
- Add batch operations (`/products/bulk-update`)
    
- Add expiry for perishable items
    
- Add audit logs for every stock movement
    
- Add role-based access control (Admin/Manager roles)
    
- Export inventory report as CSV
    

---

If you want the next backend question, I can prepare:

‚û°Ô∏è **9. Rate Limiter (Redis) + Caching System**  
‚û°Ô∏è **10. File Upload System (S3 + Validation)**  
‚û°Ô∏è **11. Order + Payment System**  
‚û°Ô∏è **12. Real-time Notifications (Webhooks/Sockets)**

Just tell me ‚Äî what‚Äôs the next round?