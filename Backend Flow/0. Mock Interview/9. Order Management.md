Alright Rahul, here comes a clean, interview-level **Backend Machine Coding Round** mock question for an **Order Management System**.  
This is a classic backend evaluation problem because it checks **data modeling, multi-step business logic, status flow, price calculation, and consistency**.

I‚Äôll keep it simple but deep enough to match real-world standards.

---

# üßæ **Backend Machine Coding Round ‚Äî Order Management System**

### ‚è± Time Limit: 60‚Äì75 minutes

### üéØ Goal: Build a backend service that supports creation, status tracking, cancellation, and pricing of orders.

---

# üìù **Problem Statement**

Design and implement a **mini Order Management backend** where users can:

- Create an order
    
- Cancel an order
    
- Check order status
    
- Manage pricing & totals
    
- Ensure consistent updates
    

Architecture expected:

- **Routes**
    
- **Controller**
    
- **Service (business logic)**
    
- **Repository / Data layer**
    

Database can be SQL, Mongo, or in-memory.

---

# üõç **Product Model**

```json
{
  "id": "uuid",
  "name": "Laptop",
  "price": 35000
}
```

---

# üì¶ **Order Item Model**

```json
{
  "productId": "uuid",
  "quantity": 2,
  "unitPrice": 35000,
  "total": 70000
}
```

---

# üß∫ **Order Model Structure**

```json
{
  "id": "uuid",
  "userId": "user_123",
  "items": [...OrderItem],
  "status": "PLACED",     // PLACED, CANCELLED
  "totalAmount": 70000,
  "createdAt": "...",
  "updatedAt": "..."
}
```

---

# üîß **Required Endpoints**

```
POST    /orders
GET     /orders/:id
PUT     /orders/:id/cancel
GET     /orders/:id/status
```

---

# üí° **Functional Requirements**

## **1Ô∏è‚É£ Create Order ‚Äî POST /orders**

Input:

```json
{
  "userId": "user_123",
  "items": [
    { "productId": "p1", "quantity": 2 },
    { "productId": "p2", "quantity": 1 }
  ]
}
```

Rules:

- Validate:
    
    - products exist
        
    - quantity > 0
        
- Fetch product prices
    
- Compute:
    
    - item total = price * quantity
        
    - totalAmount = sum of all item totals
        
- Create order with:
    
    - status = "PLACED"
        
    - timestamps
        
- Return full order response
    

---

## **2Ô∏è‚É£ Cancel Order ‚Äî PUT /orders/:id/cancel**

Rules:

- Order must exist
    
- Only orders with `PLACED` status can be cancelled
    
- Change status ‚Üí `CANCELLED`
    
- Update timestamps
    
- Return success message
    

Optional (bonus):

- Refund logic (not mandatory for this round)
    
- Prevent cancellation after N minutes
    

---

## **3Ô∏è‚É£ Get Order Info ‚Äî GET /orders/:id**

Return:

- items
    
- prices
    
- totalAmount
    
- status
    
- timestamps
    

---

## **4Ô∏è‚É£ Order Status ‚Äî GET /orders/:id/status**

Return simple object:

```json
{
  "orderId": "123",
  "status": "PLACED"
}
```

---

# üß™ **Edge Cases to Cover**

- Invalid productId ‚Üí reject
    
- Quantity <= 0 ‚Üí reject
    
- Creating empty order ‚Üí reject
    
- Cancelling already cancelled order ‚Üí reject
    
- Cancelling non-existent order ‚Üí 404
    
- Retrieving non-existent order ‚Üí 404
    
- Large totalAmount values ‚Üí handle integer overflow
    
- Price changes in products:
    
    - Using **unitPrice snapshot** saved in order ensures consistency
        
- Order items must always store:
    
    - unitPrice
        
    - total (price * quantity)
        
- Do not recalc on GET (use stored values!)
    

---

# üîí **Consistency Requirements (Important)**

- Order creation must be **atomic**
    
    - If one item fails ‚Üí rollback entire order
        
- Should not allow partial order creation
    
- Order status changes must be safe
    
- Prices must be locked at order creation time
    
- orderId must be unique
    

---

# üìä **Example Responses**

### Create Order Success

```json
{
  "id": "o1",
  "userId": "user_123",
  "status": "PLACED",
  "items": [
    { "productId": "p1", "quantity": 2, "unitPrice": 500, "total": 1000 },
    { "productId": "p2", "quantity": 1, "unitPrice": 800, "total": 800 }
  ],
  "totalAmount": 1800
}
```

### Cancel Order

```json
{
  "success": true,
  "message": "Order cancelled successfully"
}
```

---

# ‚≠ê **Interviewer Follow-Up Questions**

1. How would you add **payment workflow** (order ‚Üí payment ‚Üí confirmation)?
    
2. How would you handle **inventory reduction** upon order creation?
    
3. How would you integrate **refund logic** on cancellation?
    
4. How would you support **order history** per user?
    
5. How would you add **order status lifecycle** (PLACED ‚Üí PROCESSING ‚Üí SHIPPED ‚Üí DELIVERED)?
    
6. How would you optimize **bulk order creation**?
    
7. How would you support discount coupons & promotions?
    
8. How would you scale this system for millions of orders?
    

---

# üåü **Bonus Features (Great Impressions)**

- Add pagination for list of orders
    
- Add filtering by status
    
- Add order summary cache (Redis)
    
- Add order timelines (history of status changes)
    
- Add shipping/tracking id flow
    
- Add email notifications upon order placement
    

---

If you want, I can prepare the next backend round:

‚û°Ô∏è **10. Payment System (mini Razorpay clone)**  
‚û°Ô∏è **11. File Upload + Validation + S3**  
‚û°Ô∏è **12. Rate Limiting + Caching (Redis)**  
‚û°Ô∏è **13. Notification System (email, SMS, webhooks)**

Just tell me the next!