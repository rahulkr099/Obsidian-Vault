Here you go Rahul!  
Here‚Äôs a **clear, simple, beginner-friendly pseudocode** for your Drag-and-Drop Sortable List.  
This explains the whole logic step-by-step so you understand how sorting works with mouse dragging.

---

# ‚úÖ **Drag & Drop Sortable List ‚Äì Pseudocode**

```
Get the sortable list element
Create a variable draggedItem = null

WHEN a list item starts dragging:
    Set draggedItem = the item being dragged
    Add CSS class "dragging" to highlight it

WHEN dragging ends:
    Remove the "dragging" class
    Set draggedItem = null

WHEN dragging over the list:
    Prevent default so drop is allowed
    Find the element that is right below the mouse cursor
        (getDragAfterElement: the element that comes after the mouse cursor position)
    getDragAfterElement(list, mouseY)

    IF there is no item after the cursor:
        Append the dragged item to the end of the list
    ELSE:
        Insert the dragged item before the found element```
```

```
FUNCTION getDragAfterElement(container, mouseY):

    // 1. Get all items in the list EXCEPT the one currently being dragged
    elements = all <li> inside container that do NOT have class "dragging"

    // 2. Start with "closest element" as:
    //    offset = the smallest possible number (means no element found yet)
    closest = { offset: -infinity, element: NONE }

    // 3. Go through each element in the list
    FOR EACH child IN elements:

        // Get the position of this child on the screen
        box = child.getBoundingRectangle()

        // Calculate how far the mouse is vertically from the CENTER of this child
        offset = mouseY - (box.top + box.height / 2)

        // We care only about elements BELOW the mouse cursor
        IF offset is negative AND offset is greater than closest.offset THEN

            // This child is the closest element below the cursor
            closest.offset = offset
            closest.element = child

        END IF

    END FOR

    // 4. Return the element that was closest below the cursor
    RETURN closest.element

```
```
offset = mouseY - (item center Y)

Meaning:

    offset negative ‚Üí mouse is ABOVE the element

    offset close to zero ‚Üí closest element just below the mouse

    offset positive ‚Üí mouse is already BELOW the element (ignore)
```
---
# üé® **Visual Thinking**


```
Item A 
Item B (mouse here) 
Item C ‚Üê this one should be returned 
Item D
```

- For A & B ‚Üí offset becomes _positive_ ‚Üí ignore
- For C ‚Üí offset is small negative ‚Üí best match
- For D ‚Üí offset is bigger negative ‚Üí not the closest

So function returns **Item C**.